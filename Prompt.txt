Crypto AI Agent Aggregator - Comprehensive Technical Specification
1. Project Overview
1.1 Vision & Purpose
X√¢y d·ª±ng m·ªôt ·ª©ng d·ª•ng web real-time analytics platform mang t√™n "Crypto AI Agent". ·ª®ng d·ª•ng n√†y s·∫Ω t·ªïng h·ª£p, ph√¢n t√≠ch v√† ƒë√°nh gi√° d·ªØ li·ªáu cryptocurrency t·ª´ nhi·ªÅu ngu·ªìn uy t√≠n, k·∫øt h·ª£p v·ªõi AI ƒë·ªÉ cung c·∫•p insights chuy√™n s√¢u cho nh√† ƒë·∫ßu t∆∞ v√† trader.
1.2 Core Philosophy

Zero Database Dependency: Kh√¥ng s·ª≠ d·ª•ng b·∫•t k·ª≥ database n√†o (SQL/NoSQL)
Live Data First: M·ªçi d·ªØ li·ªáu ƒë·ªÅu ƒë∆∞·ª£c fetch real-time t·ª´ external APIs
Smart Caching: S·ª≠ d·ª•ng in-memory cache ƒë·ªÉ t·ªëi ∆∞u performance v√† gi·∫£m API calls
AI-Powered Insights: T√≠ch h·ª£p Gemini AI ƒë·ªÉ ph√¢n t√≠ch v√† ƒë∆∞a ra nh·∫≠n ƒë·ªãnh th√¥ng minh

1.3 Key Features

Real-time crypto data aggregation t·ª´ 3+ ngu·ªìn
Proprietary scoring algorithm ƒë·ªÉ ƒë√°nh gi√° trust level
AI-powered analysis cho t·ª´ng token
Responsive dashboard v·ªõi filtering & sorting
Performance optimization v·ªõi concurrent processing


2. Technology Stack
2.1 Backend Stack

Language: Golang 1.21+
Web Framework: Gin (v1.9+)
Concurrency: Native Goroutines & Channels
In-Memory Cache: go-cache ho·∫∑c bigcache
HTTP Client: net/http v·ªõi custom timeout & retry logic
AI SDK: google-generativeai-go

2.2 Frontend Stack

Framework: Vue 3 (Composition API v·ªõi <script setup>)
UI Library: Tailwind CSS 3.x
HTTP Client: Axios v·ªõi interceptors
State Management: Pinia (n·∫øu c·∫ßn ph·ª©c t·∫°p) ho·∫∑c reactive refs
Markdown Rendering: vue3-markdown-it ho·∫∑c marked + DOMPurify
Icons: Heroicons ho·∫∑c Lucide

2.3 External APIs

DeFiLlama: https://api.llama.fi/protocols - TVL, Category, Changes
CoinGecko: https://api.coingecko.com/api/v3/coins/markets - Price, Market Cap, Volume
DexScreener: https://api.dexscreener.com/latest/dex/tokens/{address} - Liquidity, Trading pairs
Gemini AI: Google AI Studio API (Gemini 1.5 Flash)


3. Backend Implementation (Golang)
3.1 Project Structure
crypto-agent-backend/
‚îú‚îÄ‚îÄ main.go                 # Entry point, server setup
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ config.go          # Environment variables, constants
‚îú‚îÄ‚îÄ handlers/
‚îÇ   ‚îú‚îÄ‚îÄ tokens.go          # GET /api/tokens handler
‚îÇ   ‚îî‚îÄ‚îÄ analyze.go         # POST /api/analyze handler
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ aggregator.go      # Data fetching & merging logic
‚îÇ   ‚îú‚îÄ‚îÄ scoring.go         # Trust score calculation
‚îÇ   ‚îî‚îÄ‚îÄ ai.go              # Gemini AI integration
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ token.go           # Token struct definitions
‚îÇ   ‚îî‚îÄ‚îÄ response.go        # API response structs
‚îú‚îÄ‚îÄ cache/
‚îÇ   ‚îî‚îÄ‚îÄ memory.go          # In-memory cache wrapper
‚îî‚îÄ‚îÄ utils/
    ‚îú‚îÄ‚îÄ http.go            # HTTP client helpers
    ‚îî‚îÄ‚îÄ merger.go          # Data merging utilities
3.2 Core Endpoint: GET /api/tokens
3.2.1 Request Parameters
Query Params:
- min_mcap (optional): Minimum market cap filter (float64)
- max_mcap (optional): Maximum market cap filter (float64)
- limit (optional): Number of results to return (default: 50, max: 200)
- category (optional): Filter by category (DeFi, DEX, Lending, etc.)
3.2.2 Response Format
json{
  "status": "success",
  "timestamp": "2024-01-30T10:30:00Z",
  "total": 150,
  "data": [
    {
      "rank": 1,
      "symbol": "SOL",
      "name": "Solana",
      "price": 98.45,
      "market_cap": 42000000000,
      "volume_24h": 2100000000,
      "tvl": 1800000000,
      "liquidity": 850000000,
      "category": "Layer 1",
      "change_1h": 0.8,
      "change_24h": 5.2,
      "change_7d": 12.5,
      "trust_score": 87.5,
      "score_breakdown": {
        "liquidity_score": 35.2,
        "volume_score": 28.8,
        "tvl_score": 23.5
      }
    }
  ],
  "fetch_time_ms": 1850
}
3.2.3 Implementation Details
A. Concurrent Data Fetching
go// aggregator.go
func FetchAllTokenData(ctx context.Context) ([]Token, error) {
    var (
        defillama    []DefiLlamaProtocol
        coingecko    []CoinGeckoMarket
        dexscreener  map[string]DexData
        errs         []error
    )
    
    // Create channels for results
    defiChan := make(chan []DefiLlamaProtocol)
    cgChan := make(chan []CoinGeckoMarket)
    dexChan := make(chan map[string]DexData)
    errChan := make(chan error, 3)
    
    // Launch goroutines
    go fetchDefiLlama(ctx, defiChan, errChan)
    go fetchCoinGecko(ctx, cgChan, errChan)
    go fetchDexScreener(ctx, dexChan, errChan)
    
    // Collect results with timeout
    timeout := time.After(5 * time.Second)
    completed := 0
    
    for completed < 3 {
        select {
        case data := <-defiChan:
            defillama = data
            completed++
        case data := <-cgChan:
            coingecko = data
            completed++
        case data := <-dexChan:
            dexscreener = data
            completed++
        case err := <-errChan:
            errs = append(errs, err)
            completed++
        case <-timeout:
            return nil, fmt.Errorf("fetch timeout")
        }
    }
    
    // Merge data even if some sources failed
    return MergeTokenData(defillama, coingecko, dexscreener), nil
}
B. HTTP Client Configuration
go// utils/http.go
var httpClient = &http.Client{
    Timeout: 3 * time.Second,
    Transport: &http.Transport{
        MaxIdleConns:        100,
        MaxIdleConnsPerHost: 10,
        IdleConnTimeout:     90 * time.Second,
    },
}

func FetchWithRetry(url string, maxRetries int) (*http.Response, error) {
    var resp *http.Response
    var err error
    
    for i := 0; i < maxRetries; i++ {
        resp, err = httpClient.Get(url)
        if err == nil && resp.StatusCode == 200 {
            return resp, nil
        }
        
        if resp != nil && resp.StatusCode == 429 {
            time.Sleep(time.Duration(i+1) * time.Second)
            continue
        }
        
        if err != nil {
            time.Sleep(500 * time.Millisecond)
            continue
        }
    }
    
    return nil, fmt.Errorf("max retries exceeded: %w", err)
}
C. Data Merging Logic
go// utils/merger.go
func MergeTokenData(
    defillama []DefiLlamaProtocol,
    coingecko []CoinGeckoMarket,
    dexscreener map[string]DexData,
) []Token {
    symbolMap := make(map[string]*Token)
    
    // First pass: CoinGecko (most reliable for price/mcap)
    for _, cg := range coingecko {
        token := &Token{
            Symbol:     strings.ToUpper(cg.Symbol),
            Name:       cg.Name,
            Price:      cg.CurrentPrice,
            MarketCap:  cg.MarketCap,
            Volume24h:  cg.TotalVolume,
            Change1h:   cg.PriceChangePercentage1h,
            Change24h:  cg.PriceChangePercentage24h,
            Change7d:   cg.PriceChangePercentage7d,
        }
        symbolMap[token.Symbol] = token
    }
    
    // Second pass: DeFiLlama (TVL data)
    for _, dl := range defillama {
        symbol := strings.ToUpper(dl.Symbol)
        if token, exists := symbolMap[symbol]; exists {
            token.TVL = dl.TVL
            token.Category = dl.Category
        }
    }
    
    // Third pass: DexScreener (liquidity)
    for symbol, dex := range dexscreener {
        if token, exists := symbolMap[symbol]; exists {
            token.Liquidity = dex.Liquidity.USD
        }
    }
    
    return mapToSlice(symbolMap)
}
3.3 Scoring Algorithm Implementation
3.3.1 Trust Score Formula
go// services/scoring.go

type ScoreBreakdown struct {
    LiquidityScore float64 `json:"liquidity_score"`
    VolumeScore    float64 `json:"volume_score"`
    TVLScore       float64 `json:"tvl_score"`
}

func CalculateTrustScore(token *Token) (float64, ScoreBreakdown) {
    var breakdown ScoreBreakdown
    
    // Liquidity Score (40% weight)
    if token.MarketCap > 0 {
        liquidityRatio := token.Liquidity / token.MarketCap
        breakdown.LiquidityScore = normalizeLiquidityScore(liquidityRatio) * 40
    }
    
    // Volume Score (30% weight)
    if token.MarketCap > 0 {
        volumeRatio := token.Volume24h / token.MarketCap
        breakdown.VolumeScore = normalizeVolumeScore(volumeRatio) * 30
    }
    
    // TVL Score (30% weight)
    if token.TVL > 0 && token.MarketCap > 0 {
        mcapTVLRatio := token.MarketCap / token.TVL
        breakdown.TVLScore = normalizeTVLScore(mcapTVLRatio) * 30
    }
    
    totalScore := breakdown.LiquidityScore + 
                  breakdown.VolumeScore + 
                  breakdown.TVLScore
    
    return math.Min(totalScore, 100), breakdown
}

// Liquidity/MarketCap ratio scoring
// Optimal range: 0.01 - 0.05 (1% - 5%)
func normalizeLiquidityScore(ratio float64) float64 {
    switch {
    case ratio >= 0.05:
        return 1.0
    case ratio >= 0.03:
        return 0.9
    case ratio >= 0.01:
        return 0.7
    case ratio >= 0.005:
        return 0.5
    default:
        return 0.3
    }
}

// Volume/MarketCap ratio scoring
// Optimal range: 0.1 - 0.5 (10% - 50%)
func normalizeVolumeScore(ratio float64) float64 {
    switch {
    case ratio >= 0.5:
        return 1.0
    case ratio >= 0.3:
        return 0.95
    case ratio >= 0.1:
        return 0.8
    case ratio >= 0.05:
        return 0.5
    default:
        return 0.2
    }
}

// MarketCap/TVL ratio scoring
// Optimal: < 1 (TVL > MarketCap)
func normalizeTVLScore(ratio float64) float64 {
    switch {
    case ratio < 0.5:
        return 1.0
    case ratio < 1.0:
        return 0.9
    case ratio < 2.0:
        return 0.7
    case ratio < 5.0:
        return 0.4
    default:
        return 0.1
    }
}
3.3.2 Filtering & Sorting
go// handlers/tokens.go
func FilterAndSortTokens(tokens []Token, params FilterParams) []Token {
    filtered := make([]Token, 0)
    
    for _, token := range tokens {
        // Market cap filter
        if params.MinMcap > 0 && token.MarketCap < params.MinMcap {
            continue
        }
        if params.MaxMcap > 0 && token.MarketCap > params.MaxMcap {
            continue
        }
        
        // Category filter
        if params.Category != "" && token.Category != params.Category {
            continue
        }
        
        filtered = append(filtered, token)
    }
    
    // Sort by score DESC
    sort.Slice(filtered, func(i, j int) bool {
        return filtered[i].TrustScore > filtered[j].TrustScore
    })
    
    // Apply limit
    if params.Limit > 0 && len(filtered) > params.Limit {
        filtered = filtered[:params.Limit]
    }
    
    // Add rankings
    for i := range filtered {
        filtered[i].Rank = i + 1
    }
    
    return filtered
}
3.4 Gemini AI Integration
3.4.1 Endpoint: POST /api/analyze
Request Body:
json{
  "symbol": "SOL",
  "name": "Solana",
  "price": 98.45,
  "market_cap": 42000000000,
  "volume_24h": 2100000000,
  "tvl": 1800000000,
  "trust_score": 87.5,
  "change_24h": 5.2,
  "change_7d": 12.5
}
Response:
json{
  "status": "success",
  "cached": false,
  "analysis": "**Solana (SOL)** ƒëang th·ªÉ hi·ªán xu h∆∞·ªõng t√≠ch c·ª±c v·ªõi trust score cao (87.5/100)...",
  "generated_at": "2024-01-30T10:35:00Z"
}
3.4.2 Implementation
go// services/ai.go
import (
    "context"
    "fmt"
    "github.com/google/generative-ai-go/genai"
    "google.golang.org/api/option"
)

type AIService struct {
    client *genai.Client
    model  *genai.GenerativeModel
    cache  *cache.Cache
}

func NewAIService(apiKey string) (*AIService, error) {
    ctx := context.Background()
    client, err := genai.NewClient(ctx, option.WithAPIKey(apiKey))
    if err != nil {
        return nil, err
    }
    
    model := client.GenerativeModel("gemini-1.5-flash")
    model.SetTemperature(0.7)
    model.SetTopP(0.9)
    model.SetMaxOutputTokens(300)
    
    return &AIService{
        client: client,
        model:  model,
        cache:  cache.New(60*time.Minute, 10*time.Minute),
    }, nil
}

func (s *AIService) AnalyzeToken(ctx context.Context, token Token) (string, bool, error) {
    cacheKey := fmt.Sprintf("analysis_%s", token.Symbol)
    
    // Check cache first
    if cached, found := s.cache.Get(cacheKey); found {
        return cached.(string), true, nil
    }
    
    // Build prompt
    prompt := s.buildAnalysisPrompt(token)
    
    // Call Gemini API
    resp, err := s.model.GenerateContent(ctx, genai.Text(prompt))
    if err != nil {
        return "", false, err
    }
    
    if len(resp.Candidates) == 0 || len(resp.Candidates[0].Content.Parts) == 0 {
        return "", false, fmt.Errorf("empty response from AI")
    }
    
    analysis := fmt.Sprintf("%v", resp.Candidates[0].Content.Parts[0])
    
    // Cache result
    s.cache.Set(cacheKey, analysis, cache.DefaultExpiration)
    
    return analysis, false, nil
}

func (s *AIService) buildAnalysisPrompt(token Token) string {
    return fmt.Sprintf(`B·∫°n l√† m·ªôt chuy√™n gia ph√¢n t√≠ch cryptocurrency chuy√™n s√¢u.

H√£y ph√¢n t√≠ch token sau v√† ƒë∆∞a ra nh·∫≠n ƒë·ªãnh ng·∫Øn g·ªçn (< 200 t·ª´) v·ªÅ:
1. Ti·ªÅm nƒÉng tƒÉng tr∆∞·ªüng
2. R·ªßi ro c·∫ßn l∆∞u √Ω
3. Khuy·∫øn ngh·ªã cho nh√† ƒë·∫ßu t∆∞

Th√¥ng tin token:
- T√™n: %s (%s)
- Gi√° hi·ªán t·∫°i: $%.2f
- Market Cap: $%.0f
- Volume 24h: $%.0f
- TVL: $%.0f
- Trust Score: %.1f/100
- Bi·∫øn ƒë·ªông 24h: %.2f%%
- Bi·∫øn ƒë·ªông 7d: %.2f%%

Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát, s·ª≠ d·ª•ng markdown formatting.`,
        token.Name,
        token.Symbol,
        token.Price,
        token.MarketCap,
        token.Volume24h,
        token.TVL,
        token.TrustScore,
        token.Change24h,
        token.Change7d,
    )
}
3.4.3 Cache Management
go// cache/memory.go
import "github.com/patrickmn/go-cache"

type CacheManager struct {
    tokenCache    *cache.Cache
    analysisCache *cache.Cache
}

func NewCacheManager() *CacheManager {
    return &CacheManager{
        // Token data cache: 5 minutes
        tokenCache: cache.New(5*time.Minute, 10*time.Minute),
        
        // AI analysis cache: 60 minutes
        analysisCache: cache.New(60*time.Minute, 120*time.Minute),
    }
}

func (c *CacheManager) GetTokens(key string) ([]Token, bool) {
    if data, found := c.tokenCache.Get(key); found {
        return data.([]Token), true
    }
    return nil, false
}

func (c *CacheManager) SetTokens(key string, tokens []Token) {
    c.tokenCache.Set(key, tokens, cache.DefaultExpiration)
}
```

---

## 4. Frontend Implementation (Vue 3)

### 4.1 Project Structure
```
crypto-agent-frontend/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.js
‚îÇ   ‚îú‚îÄ‚îÄ App.vue
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TokenTable.vue       # Main data table
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TokenRow.vue         # Individual row
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FilterBar.vue        # Filter controls
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ScoreBadge.vue       # Score visualization
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoadingSkeleton.vue  # Loading state
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TokenDetailModal.vue # Detail popup
‚îÇ   ‚îú‚îÄ‚îÄ composables/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useTokens.js         # Token data management
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useAIAnalysis.js     # AI analysis logic
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api.js               # Axios instance & endpoints
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îú‚îÄ‚îÄ formatters.js        # Number/currency formatting
‚îÇ       ‚îî‚îÄ‚îÄ colors.js            # Score color mapping
4.2 Main Dashboard Component
vue<!-- components/TokenTable.vue -->
<script setup>
import { ref, computed, onMounted } from 'vue'
import { useTokens } from '@/composables/useTokens'
import FilterBar from './FilterBar.vue'
import TokenRow from './TokenRow.vue'
import LoadingSkeleton from './LoadingSkeleton.vue'
import TokenDetailModal from './TokenDetailModal.vue'

const { tokens, loading, error, fetchTokens, filters } = useTokens()
const selectedToken = ref(null)
const showDetail = ref(false)

const filteredTokens = computed(() => {
  return tokens.value.filter(token => {
    if (filters.minMcap && token.market_cap < filters.minMcap) return false
    if (filters.maxMcap && token.market_cap > filters.maxMcap) return false
    if (filters.category && token.category !== filters.category) return false
    return true
  })
})

onMounted(() => {
  fetchTokens()
  // Auto-refresh every 5 minutes
  setInterval(fetchTokens, 5 * 60 * 1000)
})

const openDetail = (token) => {
  selectedToken.value = token
  showDetail.value = true
}
</script>

<template>
  <div class="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900">
    <div class="container mx-auto px-4 py-8">
      <!-- Header -->
      <header class="mb-8">
        <h1 class="text-4xl font-bold text-white mb-2">
          ü§ñ Crypto AI Agent
        </h1>
        <p class="text-gray-400">
          Real-time analysis powered by AI ‚Ä¢ Data updates every 5 minutes
        </p>
      </header>

      <!-- Filter Bar -->
      <FilterBar v-model="filters" @refresh="fetchTokens" />

      <!-- Loading State -->
      <LoadingSkeleton v-if="loading" />

      <!-- Error State -->
      <div v-else-if="error" class="bg-red-900/20 border border-red-500 rounded-lg p-6">
        <p class="text-red-400">{{ error }}</p>
        <button @click="fetchTokens" class="mt-4 btn-primary">
          Retry
        </button>
      </div>

      <!-- Data Table -->
      <div v-else class="bg-slate-800/50 backdrop-blur rounded-xl overflow-hidden">
        <table class="w-full">
          <thead class="bg-slate-700/50">
            <tr>
              <th class="px-6 py-4 text-left">#</th>
              <th class="px-6 py-4 text-left">Token</th>
              <th class="px-6 py-4 text-right">Price</th>
              <th class="px-6 py-4 text-right">Market Cap</th>
              <th class="px-6 py-4 text-right">Volume 24h</th>
              <th class="px-6 py-4 text-right">TVL</th>
              <th class="px-6 py-4 text-center">Trust Score</th>
              <th class="px-6 py-4 text-center">24h</th>
            </tr>
          </thead>
          <tbody>
            <TokenRow
              v-for="token in filteredTokens"
              :key="token.symbol"
              :token="token"
              @click="openDetail(token)"
            />
          </tbody>
        </table>
      </div>

      <!-- Token Detail Modal -->
      <TokenDetailModal
        v-if="showDetail"
        :token="selectedToken"
        @close="showDetail = false"
      />
    </div>
  </div>
</template>
4.3 Score Badge Component
vue<!-- components/ScoreBadge.vue -->
<script setup>
import { computed } from 'vue'

const props = defineProps({
  score: {
    type: Number,
    required: true
  },
  size: {
    type: String,
    default: 'md' // sm, md, lg
  }
})

const scoreColor = computed(() => {
  if (props.score >= 70) return 'green'
  if (props.score >= 40) return 'yellow'
  return 'red'
})

const sizeClasses = computed(() => {
  const sizes = {
    sm: 'w-12 h-12 text-xs',
    md: 'w-16 h-16 text-sm',
    lg: 'w-20 h-20 text-base'
  }
  return sizes[props.size]
})
</script>

<template>
  <div 
    class="rounded-full flex items-center justify-center font-bold relative"
    :class="[sizeClasses]"
  >
    <!-- Background circle -->
    <svg class="absolute inset-0 w-full h-full -rotate-90">
      <circle
        cx="50%"
        cy="50%"
        :r="size === 'lg' ? 36 : size === 'md' ? 28 : 20"
        class="stroke-gray-700"
        stroke-width="4"
        fill="none"
      />
      <circle
        cx="50%"
        cy="50%"
        :r="size === 'lg' ? 36 : size === 'md' ? 28 : 20"
        :class="`stroke-${scoreColor}-500`"
        stroke-width="4"
        fill="none"
        :stroke-dasharray="circumference"
        :stroke-dashoffset="dashOffset"
        class="transition-all duration-500"
      />
    </svg>
    
    <!-- Score text -->
    <span :class="`text-${scoreColor}-400`">
      {{ score.toFixed(1) }}
    </span>
  </div>
</template>

<script>
export default {
  computed: {
    circumference() {
      const radius = this.size === 'lg' ? 36 : this.size === 'md' ? 28 : 20
      return 2 * Math.PI * radius
    },
    dashOffset() {
      return this.circumference * (1 - this.score / 100)
    }
  }
}
</script>
4.4 AI Analysis Modal
vue<!-- components/TokenDetailModal.vue -->
<script setup>
import { ref } from 'vue'
import { useAIAnalysis } from '@/composables/useAIAnalysis'
import { marked } from 'marked'
import DOMPurify from 'dompurify'

const props = defineProps({
  token: {
    type: Object,
    required: true
  }
})

const emit = defineEmits(['close'])

const { analysis, loading, error, analyze } = useAIAnalysis()

const handleAnalyze = async () => {
  await analyze(props.token)
}

const sanitizedHTML = computed(() => {
  if (!analysis.value) return ''
  const html = marked(analysis.value)
  return DOMPurify.sanitize(html)
})
</script>

<template>
  <div class="fixed inset-0 bg-black/70 flex items-center justify-center p-4 z-50">
    <div class="bg-slate-800 rounded-xl max-w-2xl w-full max-h-[90vh] overflow-y-auto">
      <!-- Header -->
      <div class="sticky top-0 bg-slate-800 border-b border-slate-700 p-6">
        <div class="flex justify-between items-start">
          <div>
            <h2 class="text-2xl font-bold text-white">
              {{ token.name }} ({{ token.symbol }})
            </h2>
            <p class="text-gray-400 mt-1">
              ${{ token.price.toFixed(2) }} ‚Ä¢ MCap: ${{ formatMcap(token.market_cap) }}
            </p>
          </div>
          <button @click="emit('close')" class="text-gray-400 hover:text-white">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
      </div>

      <!-- Stats Grid -->
      <div class="p-6 grid grid-cols-2 gap-4">
        <div class="bg-slate-700/50 rounded-lg p-4">
          <p class="text-gray-400 text-sm">Volume 24h</p>
          <p class="text-white text-xl font-bold">${{ formatNumber(token.volume_24h) }}</p>
        </div>
        <div class="bg-slate-700/50 rounded-lg p-4">
          <p class="text-gray-400 text-sm">TVL</p>
          <p class="text-white text-xl font-bold">${{ formatNumber(token.tvl) }}</p>
        </div>
        <div class="bg-slate-700/50 rounded-lg p-4">
          <p class="text-gray-400 text-sm">Change 24h</p>
          <p :class="token.change_24h >= 0 ? 'text-green-400' : 'text-red-400'" class="text-xl font-bold">
            {{ token.change_24h >= 0 ? '+' : '' }}{{ token.change_24h.toFixed(2) }}%
          </p>
        </div>
        <div class="bg-slate-700/50 rounded-lg p-4">
          <p class="text-gray-400 text-sm">Trust Score</p>
          <p class="text-white text-xl font-bold">{{ token.trust_score.toFixed(1) }}/100</p>
        </div>
      </div>

      <!-- AI Analysis Section -->
      <div class="p-6 border-t border-slate-700">
        <button
          v-if="!analysis"
          @click="handleAnalyze"
          :disabled="loading"
          class="w-full bg-gradient-to-r from-purple-600 to-blue-600 text-white py-3 rounded-lg font-semibold hover:from-purple-700 hover:to-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {{ loading ? 'ü§ñ Analyzing...' : 'ü§ñ Ph√¢n t√≠ch chuy√™n s√¢u v·ªõi AI' }}
        </button>

        <div v-else class="bg-slate-700/30 rounded-lg p-6">
          <h3 class="text-lg font-semibold text-white mb-4">
            AI Analysis
          </h3>
          <div 
            class="prose prose-invert prose-sm max-w-none"
            v-html="sanitizedHTML"
          />
          <p class="text-gray-500 text-xs mt-4">
            {{ analysis.cached ? 'üì¶ Cached result' : '‚ú® Freshly generated' }}
          </p>
        </div>

        <p v-if="error" class="text-red-400 mt-4">{{ error }}</p>
      </div>
    </div>
  </div>
</template>
4.5 Composables
javascript// composables/useTokens.js
import { ref } from 'vue'
import api from '@/services/api'

export function useTokens() {
  const tokens = ref([])
  const loading = ref(false)
  const error = ref(null)
  const filters = ref({
    minMcap: null,
    maxMcap: null,
    category: null
  })

  const fetchTokens = async () => {
    loading.value = true
    error.value = null
    
    try {
      const params = {}
      if (filters.value.minMcap) params.min_mcap = filters.value.minMcap
      if (filters.value.maxMcap) params.max_mcap = filters.value.maxMcap
      if (filters.value.category) params.category = filters.value.category
      
      const response = await api.get('/tokens', { params })
      tokens.value = response.data.data
    } catch (err) {
      error.value = err.message || 'Failed to fetch tokens'
      console.error('Fetch error:', err)
    } finally {
      loading.value = false
    }
  }

  return {
    tokens,
    loading,
    error,
    filters,
    fetchTokens
  }
}

// composables/useAIAnalysis.js
import { ref } from 'vue'
import api from '@/services/api'

export function useAIAnalysis() {
  const analysis = ref(null)
  const loading = ref(false)
  const error = ref(null)

  const analyze = async (token) => {
    loading.value = true
    error.value = null
    
    try {
      const response = await api.post('/analyze', {
        symbol: token.symbol,
        name: token.name,
        price: token.price,
        market_cap: token.market_cap,
        volume_24h: token.volume_24h,
        tvl: token.tvl,
        trust_score: token.trust_score,
        change_24h: token.change_24h,
        change_7d: token.change_7d
      })
      
      analysis.value = response.data.analysis
      analysis.value.cached = response.data.cached
    } catch (err) {
      error.value = err.message || 'Failed to analyze token'
      console.error('Analysis error:', err)
    } finally {
      loading.value = false
    }
  }

  return {
    analysis,
    loading,
    error,
    analyze
  }
}

5. Deployment & Operations
5.1 Environment Variables
Backend (.env)
bash# Server
PORT=8080
GIN_MODE=release

# API Keys
GEMINI_API_KEY=your_gemini_api_key_here

# Cache Settings
TOKEN_CACHE_DURATION=5m
ANALYSIS_CACHE_DURATION=60m

# External APIs (optional overrides)
DEFILLAMA_API_URL=https://api.llama.fi
COINGECKO_API_URL=https://api.coingecko.com/api/v3
DEXSCREENER_API_URL=https://api.dexscreener.com/latest
Frontend (.env)
bashVITE_API_BASE_URL=http://localhost:8080/api
5.2 Docker Configuration
Backend Dockerfile:
dockerfileFROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o crypto-agent

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/crypto-agent .
EXPOSE 8080
CMD ["./crypto-agent"]
docker-compose.yml:
yamlversion: '3.8'

services:
  backend:
    build: ./backend
    ports:
      - "8080:8080"
    environment:
      - GEMINI_API_KEY=${GEMINI_API_KEY}
    restart: unless-stopped

  frontend:
    build: ./frontend
    ports:
      - "3000:80"
    depends_on:
      - backend
    restart: unless-stopped