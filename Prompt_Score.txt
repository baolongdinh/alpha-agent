Enhanced Trust Score Calculation - Comprehensive Scoring System
1. Updated Scoring Formula Architecture
1.1 New Multi-Factor Scoring Model
go// models/score.go

type TrustScoreWeights struct {
    // Liquidity Metrics (25%)
    LiquidityRatio    float64 // 15%
    LiquidityDepth    float64 // 10%
    
    // Volume Metrics (20%)
    VolumeRatio       float64 // 10%
    VolumeConsistency float64 // 5%
    VolumeGrowth      float64 // 5%
    
    // TVL Metrics (20%)
    TVLScore          float64 // 10%
    TVLGrowth         float64 // 5%
    TVLStability      float64 // 5%
    
    // Price & Trend Metrics (20%)
    PriceTrend        float64 // 10%
    Volatility        float64 // 5%
    MomentumScore     float64 // 5%
    
    // Market Health Metrics (10%)
    HolderDistribution float64 // 5%
    MarketDominance    float64 // 5%
    
    // Risk Metrics (5%)
    RiskAdjustment    float64 // 5%
}

type DetailedScoreBreakdown struct {
    // Main Categories
    LiquidityScore      float64 `json:"liquidity_score"`       // 25%
    VolumeScore         float64 `json:"volume_score"`          // 20%
    TVLScore            float64 `json:"tvl_score"`             // 20%
    TrendScore          float64 `json:"trend_score"`           // 20%
    MarketHealthScore   float64 `json:"market_health_score"`   // 10%
    RiskScore           float64 `json:"risk_score"`            // 5%
    
    // Detailed Breakdown
    Details ScoreDetails `json:"details"`
    
    // Overall
    TotalScore          float64 `json:"total_score"`
    Grade               string  `json:"grade"` // S, A, B, C, D, F
    Confidence          float64 `json:"confidence"` // 0-100
}

type ScoreDetails struct {
    // Liquidity Details
    LiquidityRatio        float64 `json:"liquidity_ratio"`
    LiquidityDepth        float64 `json:"liquidity_depth"`
    
    // Volume Details
    VolumeToMcapRatio     float64 `json:"volume_to_mcap_ratio"`
    VolumeConsistency     float64 `json:"volume_consistency"`
    Volume7dGrowth        float64 `json:"volume_7d_growth"`
    
    // TVL Details
    TVLToMcapRatio        float64 `json:"tvl_to_mcap_ratio"`
    TVL7dGrowth           float64 `json:"tvl_7d_growth"`
    TVL30dGrowth          float64 `json:"tvl_30d_growth"`
    TVLVolatility         float64 `json:"tvl_volatility"`
    
    // Price & Trend Details
    ShortTermTrend        string  `json:"short_term_trend"`    // 7 days
    MediumTermTrend       string  `json:"medium_term_trend"`   // 30 days
    LongTermTrend         string  `json:"long_term_trend"`     // 90 days
    Volatility30d         float64 `json:"volatility_30d"`
    SharpeRatio           float64 `json:"sharpe_ratio"`
    RSI                   float64 `json:"rsi"`
    
    // Market Health Details
    Top10HoldersPercent   float64 `json:"top10_holders_percent"`
    UniqueHolders         int     `json:"unique_holders"`
    MarketCapRank         int     `json:"market_cap_rank"`
    
    // Risk Indicators
    RugPullRisk           string  `json:"rug_pull_risk"`      // Low, Medium, High
    CentralizationRisk    string  `json:"centralization_risk"`
    SmartContractRisk     string  `json:"smart_contract_risk"`
}
1.2 Enhanced Token Model
go// models/token.go

type EnhancedToken struct {
    // Basic Info
    Rank      int     `json:"rank"`
    Symbol    string  `json:"symbol"`
    Name      string  `json:"name"`
    Category  string  `json:"category"`
    
    // Current Metrics
    Price         float64 `json:"price"`
    MarketCap     float64 `json:"market_cap"`
    Volume24h     float64 `json:"volume_24h"`
    TVL           float64 `json:"tvl"`
    Liquidity     float64 `json:"liquidity"`
    
    // Historical Data (for trend analysis)
    PriceHistory  PriceHistory  `json:"price_history"`
    VolumeHistory VolumeHistory `json:"volume_history"`
    TVLHistory    TVLHistory    `json:"tvl_history"`
    
    // Change Metrics
    Change1h      float64 `json:"change_1h"`
    Change24h     float64 `json:"change_24h"`
    Change7d      float64 `json:"change_7d"`
    Change30d     float64 `json:"change_30d"`
    Change90d     float64 `json:"change_90d"`
    
    // Advanced Metrics
    Volume7dAvg   float64 `json:"volume_7d_avg"`
    Volume30dAvg  float64 `json:"volume_30d_avg"`
    TVL7dChange   float64 `json:"tvl_7d_change"`
    TVL30dChange  float64 `json:"tvl_30d_change"`
    
    // Technical Indicators
    RSI14         float64 `json:"rsi_14"`
    SMA7          float64 `json:"sma_7"`
    SMA30         float64 `json:"sma_30"`
    SMA90         float64 `json:"sma_90"`
    EMA12         float64 `json:"ema_12"`
    EMA26         float64 `json:"ema_26"`
    MACD          float64 `json:"macd"`
    
    // Volatility Metrics
    Volatility7d  float64 `json:"volatility_7d"`
    Volatility30d float64 `json:"volatility_30d"`
    BetaToMarket  float64 `json:"beta_to_market"`
    
    // Holder & Distribution Data
    HolderCount        int     `json:"holder_count"`
    Top10HoldersRatio  float64 `json:"top10_holders_ratio"`
    WhaleConcentration float64 `json:"whale_concentration"`
    
    // Liquidity Depth
    BidAskSpread       float64 `json:"bid_ask_spread"`
    OrderbookDepth1    float64 `json:"orderbook_depth_1"`  // 1% depth
    OrderbookDepth5    float64 `json:"orderbook_depth_5"`  // 5% depth
    
    // Smart Contract Info
    IsVerified         bool   `json:"is_verified"`
    AuditStatus        string `json:"audit_status"`
    ContractAge        int    `json:"contract_age_days"`
    
    // Social & Developer Metrics
    TwitterFollowers   int     `json:"twitter_followers"`
    GithubCommits      int     `json:"github_commits"`
    DeveloperActivity  float64 `json:"developer_activity"`
    
    // Score
    TrustScore         float64                `json:"trust_score"`
    ScoreBreakdown     DetailedScoreBreakdown `json:"score_breakdown"`
}

type PriceHistory struct {
    Last7Days  []float64 `json:"last_7_days"`
    Last30Days []float64 `json:"last_30_days"`
    Last90Days []float64 `json:"last_90_days"`
}

type VolumeHistory struct {
    Last7Days  []float64 `json:"last_7_days"`
    Last30Days []float64 `json:"last_30_days"`
}

type TVLHistory struct {
    Last7Days  []float64 `json:"last_7_days"`
    Last30Days []float64 `json:"last_30_days"`
}
2. Comprehensive Scoring Implementation
2.1 Main Scoring Function
go// services/scoring_enhanced.go

package services

import (
    "math"
    "crypto-agent/models"
)

type EnhancedScorer struct {
    weights TrustScoreWeights
}

func NewEnhancedScorer() *EnhancedScorer {
    return &EnhancedScorer{
        weights: TrustScoreWeights{
            // Liquidity (25%)
            LiquidityRatio: 15.0,
            LiquidityDepth: 10.0,
            
            // Volume (20%)
            VolumeRatio:       10.0,
            VolumeConsistency: 5.0,
            VolumeGrowth:      5.0,
            
            // TVL (20%)
            TVLScore:     10.0,
            TVLGrowth:    5.0,
            TVLStability: 5.0,
            
            // Trend (20%)
            PriceTrend:    10.0,
            Volatility:    5.0,
            MomentumScore: 5.0,
            
            // Market Health (10%)
            HolderDistribution: 5.0,
            MarketDominance:    5.0,
            
            // Risk (5%)
            RiskAdjustment: 5.0,
        },
    }
}

func (s *EnhancedScorer) CalculateComprehensiveScore(token *models.EnhancedToken) models.DetailedScoreBreakdown {
    breakdown := models.DetailedScoreBreakdown{
        Details: models.ScoreDetails{},
    }
    
    // 1. Calculate Liquidity Score (25%)
    breakdown.LiquidityScore = s.calculateLiquidityScore(token)
    
    // 2. Calculate Volume Score (20%)
    breakdown.VolumeScore = s.calculateVolumeScore(token)
    
    // 3. Calculate TVL Score (20%)
    breakdown.TVLScore = s.calculateTVLScore(token)
    
    // 4. Calculate Trend Score (20%)
    breakdown.TrendScore = s.calculateTrendScore(token)
    
    // 5. Calculate Market Health Score (10%)
    breakdown.MarketHealthScore = s.calculateMarketHealthScore(token)
    
    // 6. Calculate Risk Score (5%)
    breakdown.RiskScore = s.calculateRiskScore(token)
    
    // Calculate Total Score
    breakdown.TotalScore = breakdown.LiquidityScore +
                          breakdown.VolumeScore +
                          breakdown.TVLScore +
                          breakdown.TrendScore +
                          breakdown.MarketHealthScore +
                          breakdown.RiskScore
    
    // Assign Grade
    breakdown.Grade = s.assignGrade(breakdown.TotalScore)
    
    // Calculate Confidence
    breakdown.Confidence = s.calculateConfidence(token)
    
    return breakdown
}
2.2 Liquidity Scoring (25%)
gofunc (s *EnhancedScorer) calculateLiquidityScore(token *models.EnhancedToken) float64 {
    var score float64
    
    // A. Liquidity to Market Cap Ratio (15%)
    if token.MarketCap > 0 {
        liquidityRatio := token.Liquidity / token.MarketCap
        token.ScoreBreakdown.Details.LiquidityRatio = liquidityRatio
        
        // Optimal range: 2-10%
        var ratioScore float64
        switch {
        case liquidityRatio >= 0.10:  // >= 10%
            ratioScore = 1.0
        case liquidityRatio >= 0.05:  // 5-10%
            ratioScore = 0.95
        case liquidityRatio >= 0.02:  // 2-5%
            ratioScore = 0.9
        case liquidityRatio >= 0.01:  // 1-2%
            ratioScore = 0.7
        case liquidityRatio >= 0.005: // 0.5-1%
            ratioScore = 0.5
        default:                       // < 0.5%
            ratioScore = 0.2
        }
        
        score += ratioScore * s.weights.LiquidityRatio
    }
    
    // B. Liquidity Depth Score (10%)
    // Measure orderbook depth at 1% and 5% price levels
    depthScore := s.calculateDepthScore(
        token.OrderbookDepth1,
        token.OrderbookDepth5,
        token.MarketCap,
    )
    token.ScoreBreakdown.Details.LiquidityDepth = depthScore
    score += depthScore * s.weights.LiquidityDepth
    
    return score
}

func (s *EnhancedScorer) calculateDepthScore(depth1, depth5, mcap float64) float64 {
    if mcap == 0 {
        return 0
    }
    
    // Calculate depth as percentage of market cap
    depth1Pct := depth1 / mcap * 100
    depth5Pct := depth5 / mcap * 100
    
    // Weighted average (1% depth is more important)
    avgDepth := (depth1Pct * 0.7) + (depth5Pct * 0.3)
    
    switch {
    case avgDepth >= 5.0:  // Excellent depth
        return 1.0
    case avgDepth >= 3.0:  // Good depth
        return 0.85
    case avgDepth >= 1.0:  // Acceptable depth
        return 0.7
    case avgDepth >= 0.5:  // Thin depth
        return 0.5
    default:               // Very thin
        return 0.3
    }
}
2.3 Volume Scoring (20%)
gofunc (s *EnhancedScorer) calculateVolumeScore(token *models.EnhancedToken) float64 {
    var score float64
    
    // A. Volume to Market Cap Ratio (10%)
    if token.MarketCap > 0 {
        volumeRatio := token.Volume24h / token.MarketCap
        token.ScoreBreakdown.Details.VolumeToMcapRatio = volumeRatio
        
        // Optimal range: 10-50%
        var ratioScore float64
        switch {
        case volumeRatio >= 0.50:  // >= 50% (very high activity)
            ratioScore = 1.0
        case volumeRatio >= 0.30:  // 30-50%
            ratioScore = 0.95
        case volumeRatio >= 0.10:  // 10-30%
            ratioScore = 0.85
        case volumeRatio >= 0.05:  // 5-10%
            ratioScore = 0.6
        case volumeRatio >= 0.01:  // 1-5%
            ratioScore = 0.4
        default:                    // < 1%
            ratioScore = 0.2
        }
        
        score += ratioScore * s.weights.VolumeRatio
    }
    
    // B. Volume Consistency (5%)
    // Check if volume is consistent over time
    consistencyScore := s.calculateVolumeConsistency(token.VolumeHistory)
    token.ScoreBreakdown.Details.VolumeConsistency = consistencyScore
    score += consistencyScore * s.weights.VolumeConsistency
    
    // C. Volume Growth (5%)
    // 7-day volume growth trend
    volumeGrowth := s.calculateVolumeGrowth(token.VolumeHistory)
    token.ScoreBreakdown.Details.Volume7dGrowth = volumeGrowth
    
    var growthScore float64
    switch {
    case volumeGrowth >= 50:   // +50% growth
        growthScore = 1.0
    case volumeGrowth >= 20:   // +20% growth
        growthScore = 0.9
    case volumeGrowth >= 0:    // Stable/growing
        growthScore = 0.7
    case volumeGrowth >= -20:  // Slight decline
        growthScore = 0.5
    default:                   // Significant decline
        growthScore = 0.3
    }
    
    score += growthScore * s.weights.VolumeGrowth
    
    return score
}

func (s *EnhancedScorer) calculateVolumeConsistency(history models.VolumeHistory) float64 {
    if len(history.Last7Days) < 7 {
        return 0.5 // Insufficient data
    }
    
    // Calculate coefficient of variation
    mean := calculateMean(history.Last7Days)
    if mean == 0 {
        return 0
    }
    
    stdDev := calculateStdDev(history.Last7Days, mean)
    cv := stdDev / mean
    
    // Lower CV = more consistent = better score
    switch {
    case cv <= 0.2:  // Very consistent
        return 1.0
    case cv <= 0.4:  // Consistent
        return 0.85
    case cv <= 0.6:  // Moderately consistent
        return 0.7
    case cv <= 0.8:  // Somewhat inconsistent
        return 0.5
    default:         // Very inconsistent
        return 0.3
    }
}

func (s *EnhancedScorer) calculateVolumeGrowth(history models.VolumeHistory) float64 {
    if len(history.Last7Days) < 7 {
        return 0
    }
    
    // Compare first 3 days vs last 3 days
    early := calculateMean(history.Last7Days[:3])
    recent := calculateMean(history.Last7Days[4:])
    
    if early == 0 {
        return 0
    }
    
    return ((recent - early) / early) * 100
}
2.4 TVL Scoring (20%)
gofunc (s *EnhancedScorer) calculateTVLScore(token *models.EnhancedToken) float64 {
    var score float64
    
    // A. TVL to Market Cap Ratio (10%)
    if token.MarketCap > 0 && token.TVL > 0 {
        tvlRatio := token.TVL / token.MarketCap
        token.ScoreBreakdown.Details.TVLToMcapRatio = tvlRatio
        
        // Higher TVL relative to Mcap is better (undervalued)
        var ratioScore float64
        switch {
        case tvlRatio >= 2.0:  // TVL > 2x Mcap (very undervalued)
            ratioScore = 1.0
        case tvlRatio >= 1.0:  // TVL > Mcap
            ratioScore = 0.95
        case tvlRatio >= 0.5:  // TVL = 50-100% of Mcap
            ratioScore = 0.85
        case tvlRatio >= 0.2:  // TVL = 20-50% of Mcap
            ratioScore = 0.7
        case tvlRatio >= 0.1:  // TVL = 10-20% of Mcap
            ratioScore = 0.5
        default:               // TVL < 10% of Mcap (overvalued)
            ratioScore = 0.3
        }
        
        score += ratioScore * s.weights.TVLScore
    }
    
    // B. TVL Growth (5%)
    // Prefer protocols with growing TVL
    tvl7dGrowth := token.TVL7dChange
    tvl30dGrowth := token.TVL30dChange
    
    token.ScoreBreakdown.Details.TVL7dGrowth = tvl7dGrowth
    token.ScoreBreakdown.Details.TVL30dGrowth = tvl30dGrowth
    
    // Weight recent growth more heavily
    avgGrowth := (tvl7dGrowth * 0.7) + (tvl30dGrowth * 0.3)
    
    var growthScore float64
    switch {
    case avgGrowth >= 30:   // +30% growth
        growthScore = 1.0
    case avgGrowth >= 15:   // +15% growth
        growthScore = 0.9
    case avgGrowth >= 5:    // +5% growth
        growthScore = 0.8
    case avgGrowth >= 0:    // Stable
        growthScore = 0.7
    case avgGrowth >= -10:  // Slight decline
        growthScore = 0.5
    case avgGrowth >= -25:  // Moderate decline
        growthScore = 0.3
    default:                // Severe decline
        growthScore = 0.1
    }
    
    score += growthScore * s.weights.TVLGrowth
    
    // C. TVL Stability (5%)
    // Prefer TVL that doesn't fluctuate wildly
    tvlVolatility := s.calculateTVLVolatility(token.TVLHistory)
    token.ScoreBreakdown.Details.TVLVolatility = tvlVolatility
    
    var stabilityScore float64
    switch {
    case tvlVolatility <= 5:   // Very stable
        stabilityScore = 1.0
    case tvlVolatility <= 10:  // Stable
        stabilityScore = 0.85
    case tvlVolatility <= 20:  // Moderately volatile
        stabilityScore = 0.7
    case tvlVolatility <= 35:  // Volatile
        stabilityScore = 0.5
    default:                   // Highly volatile
        stabilityScore = 0.3
    }
    
    score += stabilityScore * s.weights.TVLStability
    
    return score
}

func (s *EnhancedScorer) calculateTVLVolatility(history models.TVLHistory) float64 {
    if len(history.Last30Days) < 30 {
        return 50.0 // High uncertainty
    }
    
    mean := calculateMean(history.Last30Days)
    if mean == 0 {
        return 100.0
    }
    
    stdDev := calculateStdDev(history.Last30Days, mean)
    return (stdDev / mean) * 100 // Coefficient of variation as percentage
}
2.5 Trend & Momentum Scoring (20%)
gofunc (s *EnhancedScorer) calculateTrendScore(token *models.EnhancedToken) float64 {
    var score float64
    
    // A. Multi-Timeframe Trend Analysis (10%)
    trendScore := s.analyzeMultiTimeframeTrend(token)
    score += trendScore * s.weights.PriceTrend
    
    // B. Volatility Score (5%)
    // Lower volatility = more stable = better for risk-adjusted returns
    volatilityScore := s.calculateVolatilityScore(token)
    score += volatilityScore * s.weights.Volatility
    
    // C. Momentum Score (5%)
    // RSI, MACD, Moving Average convergence
    momentumScore := s.calculateMomentumScore(token)
    score += momentumScore * s.weights.MomentumScore
    
    return score
}

func (s *EnhancedScorer) analyzeMultiTimeframeTrend(token *models.EnhancedToken) float64 {
    // Analyze trends across multiple timeframes
    shortTrend := s.determineTrend(token.Change7d, "short")
    mediumTrend := s.determineTrend(token.Change30d, "medium")
    longTrend := s.determineTrend(token.Change90d, "long")
    
    token.ScoreBreakdown.Details.ShortTermTrend = shortTrend
    token.ScoreBreakdown.Details.MediumTermTrend = mediumTrend
    token.ScoreBreakdown.Details.LongTermTrend = longTrend
    
    // Score based on trend alignment
    trendScore := 0.0
    
    // Best: All uptrends
    if shortTrend == "strong_uptrend" && mediumTrend == "strong_uptrend" && longTrend == "uptrend" {
        trendScore = 1.0
    } else if shortTrend == "uptrend" && mediumTrend == "uptrend" {
        trendScore = 0.9
    } else if shortTrend == "uptrend" || mediumTrend == "uptrend" {
        trendScore = 0.75
    } else if shortTrend == "sideways" && mediumTrend == "sideways" {
        trendScore = 0.6
    } else if shortTrend == "downtrend" && mediumTrend == "downtrend" {
        trendScore = 0.3
    } else {
        trendScore = 0.5 // Mixed signals
    }
    
    return trendScore
}

func (s *EnhancedScorer) determineTrend(changePercent float64, timeframe string) string {
    // Adjust thresholds based on timeframe
    var strongUp, up, strongDown, down float64
    
    switch timeframe {
    case "short": // 7 days - more sensitive
        strongUp, up, down, strongDown = 15, 5, -5, -15
    case "medium": // 30 days
        strongUp, up, down, strongDown = 30, 10, -10, -30
    case "long": // 90 days
        strongUp, up, down, strongDown = 50, 20, -20, -50
    }
    
    switch {
    case changePercent >= strongUp:
        return "strong_uptrend"
    case changePercent >= up:
        return "uptrend"
    case changePercent <= strongDown:
        return "strong_downtrend"
    case changePercent <= down:
        return "downtrend"
    default:
        return "sideways"
    }
}

func (s *EnhancedScorer) calculateVolatilityScore(token *models.EnhancedToken) float64 {
    vol30d := token.Volatility30d
    token.ScoreBreakdown.Details.Volatility30d = vol30d
    
    // Lower volatility = higher score (for stability)
    switch {
    case vol30d <= 20:  // Low volatility
        return 1.0
    case vol30d <= 40:  // Moderate volatility
        return 0.8
    case vol30d <= 60:  // High volatility
        return 0.6
    case vol30d <= 80:  // Very high volatility
        return 0.4
    default:            // Extreme volatility
        return 0.2
    }
}

func (s *EnhancedScorer) calculateMomentumScore(token *models.EnhancedToken) float64 {
    var score float64
    
    // A. RSI Analysis (40%)
    rsi := token.RSI14
    token.ScoreBreakdown.Details.RSI = rsi
    
    var rsiScore float64
    switch {
    case rsi >= 50 && rsi <= 70:  // Healthy uptrend
        rsiScore = 1.0
    case rsi >= 40 && rsi < 50:   // Neutral to slightly bearish
        rsiScore = 0.7
    case rsi > 70:                // Overbought
        rsiScore = 0.5
    case rsi >= 30 && rsi < 40:   // Oversold (potential reversal)
        rsiScore = 0.6
    default:                      // Deeply oversold
        rsiScore = 0.4
    }
    score += rsiScore * 0.4
    
    // B. Moving Average Convergence (30%)
    // Price vs SMA7, SMA30
    priceAboveSMA7 := token.Price > token.SMA7
    priceAboveSMA30 := token.Price > token.SMA30
    
    if priceAboveSMA7 && priceAboveSMA30 {
        score += 1.0 * 0.3
    } else if priceAboveSMA7 {
        score += 0.7 * 0.3
    } else if priceAboveSMA30 {
        score += 0.5 * 0.3
    } else {
        score += 0.3 * 0.3
    }
    
    // C. MACD Signal (30%)
    macd := token.MACD
    var macdScore float64
    switch {
    case macd > 0:    // Bullish
        macdScore = 1.0
    case macd > -2:   // Slightly bearish
        macdScore = 0.7
    default:          // Bearish
        macdScore = 0.4
    }
    score += macdScore * 0.3
    
    return score
}
2.6 Market Health Scoring (10%)
gofunc (s *EnhancedScorer) calculateMarketHealthScore(token *models.EnhancedToken) float64 {
    var score float64
    
    // A. Holder Distribution (5%)
    // Lower concentration = healthier distribution
    top10Ratio := token.Top10HoldersRatio
    token.ScoreBreakdown.Details.Top10HoldersPercent = top10Ratio
    
    var distributionScore float64
    switch {
    case top10Ratio <= 30:  // Very decentralized
        distributionScore = 1.0
    case top10Ratio <= 50:  // Healthy distribution
        distributionScore = 0.85
    case top10Ratio <= 70:  // Moderately concentrated
        distributionScore = 0.6
    case top10Ratio <= 85:  // Highly concentrated
        distributionScore = 0.3
    default:                // Extremely concentrated (red flag)
        distributionScore = 0.1
    }
    
    score += distributionScore * s.weights.HolderDistribution
    
    // B. Market Dominance & Maturity (5%)
    // Consider market cap rank and holder count
    token.ScoreBreakdown.Details.UniqueHolders = token.HolderCount
    token.ScoreBreakdown.Details.MarketCapRank = token.Rank
    
    var dominanceScore float64
    
    // Market Cap Rank scoring
    var rankScore float64
    switch {
    case token.Rank <= 10:   // Top 10
        rankScore = 1.0
    case token.Rank <= 50:   // Top 50
        rankScore = 0.9
    case token.Rank <= 100:  // Top 100
        rankScore = 0.8
    case token.Rank <= 200:  // Top 200
        rankScore = 0.7
    default:                 // Beyond top 200
        rankScore = 0.5
    }
    
    // Holder Count scoring
    var holderScore float64
    switch {
    case token.HolderCount >= 100000:  // 100k+ holders
        holderScore = 1.0
    case token.HolderCount >= 50000:   // 50k+ holders
        holderScore = 0.9
    case token.HolderCount >= 10000:   // 10k+ holders
        holderScore = 0.8
    case token.HolderCount >= 5000:    // 5k+ holders
        holderScore = 0.6
    case token.HolderCount >= 1000:    // 1k+ holders
        holderScore = 0.4
    default:                           // < 1k holders
        holderScore = 0.2
    }
    
    // Combine rank and holder scores
    dominanceScore = (rankScore * 0.6) + (holderScore * 0.4)
    score += dominanceScore * s.weights.MarketDominance
    
    return score
}
2.7 Risk Scoring (5%)
gofunc (s *EnhancedScorer) calculateRiskScore(token *models.EnhancedToken) float64 {
    var riskFactors []float64
    
    // A. Rug Pull Risk Assessment
    rugPullRisk := s.assessRugPullRisk(token)
    token.ScoreBreakdown.Details.RugPullRisk = rugPullRisk
    
    var rugPullScore float64
    switch rugPullRisk {
    case "Low":
        rugPullScore = 1.0
    case "Medium":
        rugPullScore = 0.6
    case "High":
        rugPullScore = 0.2
    }
    riskFactors = append(riskFactors, rugPullScore)
    
    // B. Centralization Risk
    centralizationRisk := s.assessCentralizationRisk(token)
    token.ScoreBreakdown.Details.CentralizationRisk = centralizationRisk
    
    var centralScore float64
    switch centralizationRisk {
    case "Low":
        centralScore = 1.0
    case "Medium":
        centralScore = 0.7
    case "High":
        centralScore = 0.3
    }
    riskFactors = append(riskFactors, centralScore)
    
    // C. Smart Contract Risk
    contractRisk := s.assessSmartContractRisk(token)
    token.ScoreBreakdown.Details.SmartContractRisk = contractRisk
    
    var contractScore float64
    switch contractRisk {
    case "Low":
        contractScore = 1.0
    case "Medium":
        contractScore = 0.6
    case "High":
        contractScore = 0.2
    }
    riskFactors = append(riskFactors, contractScore)
    
    // Calculate average risk score
    avgRiskScore := calculateMean(riskFactors)
    
    return avgRiskScore * s.weights.RiskAdjustment
}

func (s *EnhancedScorer) assessRugPullRisk(token *models.EnhancedToken) string {
    riskPoints := 0
    
    // High liquidity = lower risk
    if token.Liquidity < token.MarketCap*0.01 {
        riskPoints += 2
    }
    
    // High holder concentration = higher risk
    if token.Top10HoldersRatio > 70 {
        riskPoints += 2
    }
    
    // New contract = higher risk
    if token.ContractAge < 90 {
        riskPoints += 1
    }
    
    // Unverified contract = higher risk
    if !token.IsVerified {
        riskPoints += 2
    }
    
    switch {
    case riskPoints >= 5:
        return "High"
    case riskPoints >= 3:
        return "Medium"
    default:
        return "Low"
    }
}

func (s *EnhancedScorer) assessCentralizationRisk(token *models.EnhancedToken) string {
    // Based on holder distribution
    if token.Top10HoldersRatio > 80 {
        return "High"
    } else if token.Top10HoldersRatio > 60 {
        return "Medium"
    }
    return "Low"
}

func (s *EnhancedScorer) assessSmartContractRisk(token *models.EnhancedToken) string {
    riskPoints := 0
    
    // Unverified contract
    if !token.IsVerified {
        riskPoints += 2
    }
    
    // No audit or failed audit
    if token.AuditStatus != "Passed" {
        riskPoints += 2
    }
    
    // New contract
    if token.ContractAge < 180 {
        riskPoints += 1
    }
    
    switch {
    case riskPoints >= 4:
        return "High"
    case riskPoints >= 2:
        return "Medium"
    default:
        return "Low"
    }
}
2.8 Grade Assignment & Confidence
gofunc (s *EnhancedScorer) assignGrade(score float64) string {
    switch {
    case score >= 90:
        return "S"  // Exceptional
    case score >= 80:
        return "A"  // Excellent
    case score >= 70:
        return "B"  // Good
    case score >= 60:
        return "C"  // Average
    case score >= 50:
        return "D"  // Below Average
    default:
        return "F"  // Poor
    }
}

func (s *EnhancedScorer) calculateConfidence(token *models.EnhancedToken) float64 {
    // Confidence based on data completeness and quality
    confidence := 100.0
    
    // Deduct points for missing data
    if token.TVL == 0 {
        confidence -= 15
    }
    if token.Liquidity == 0 {
        confidence -= 15
    }
    if token.HolderCount == 0 {
        confidence -= 10
    }
    if len(token.PriceHistory.Last30Days) < 30 {
        confidence -= 10
    }
    if token.Volume24h < token.MarketCap*0.001 { // Very low volume
        confidence -= 10
    }
    
    // Age of token affects confidence
    if token.ContractAge < 30 {
        confidence -= 15
    } else if token.ContractAge < 90 {
        confidence -= 10
    }
    
    return math.Max(confidence, 0)
}
2.9 Utility Functions
go// utils/math.go

func calculateMean(values []float64) float64 {
    if len(values) == 0 {
        return 0
    }
    
    sum := 0.0
    for _, v := range values {
        sum += v
    }
    return sum / float64(len(values))
}

func calculateStdDev(values []float64, mean float64) float64 {
    if len(values) == 0 {
        return 0
    }
    
    sumSquares := 0.0
    for _, v := range values {
        diff := v - mean
        sumSquares += diff * diff
    }
    
    variance := sumSquares / float64(len(values))
    return math.Sqrt(variance)
}

func calculateRSI(prices []float64, period int) float64 {
    if len(prices) < period+1 {
        return 50.0 // Neutral
    }
    
    gains := 0.0
    losses := 0.0
    
    for i := 1; i <= period; i++ {
        change := prices[i] - prices[i-1]
        if change > 0 {
            gains += change
        } else {
            losses -= change
        }
    }
    
    avgGain := gains / float64(period)
    avgLoss := losses / float64(period)
    
    if avgLoss == 0 {
        return 100.0
    }
    
    rs := avgGain / avgLoss
    rsi := 100 - (100 / (1 + rs))
    
    return rsi
}

func calculateSMA(prices []float64, period int) float64 {
    if len(prices) < period {
        return 0
    }
    
    sum := 0.0
    for i := len(prices) - period; i < len(prices); i++ {
        sum += prices[i]
    }
    
    return sum / float64(period)
}

func calculateEMA(prices []float64, period int) float64 {
    if len(prices) < period {
        return 0
    }
    
    multiplier := 2.0 / float64(period+1)
    
    // Start with SMA
    ema := calculateSMA(prices[:period], period)
    
    // Calculate EMA for remaining prices
    for i := period; i < len(prices); i++ {
        ema = (prices[i]-ema)*multiplier + ema
    }
    
    return ema
}

func calculateMACD(prices []float64) float64 {
    if len(prices) < 26 {
        return 0
    }
    
    ema12 := calculateEMA(prices, 12)
    ema26 := calculateEMA(prices, 26)
    
    return ema12 - ema26
}

func calculateSharpeRatio(returns []float64, riskFreeRate float64) float64 {
    if len(returns) == 0 {
        return 0
    }
    
    meanReturn := calculateMean(returns)
    stdDev := calculateStdDev(returns, meanReturn)
    
    if stdDev == 0 {
        return 0
    }
    
    excessReturn := meanReturn - riskFreeRate
    return excessReturn / stdDev
}
3. Enhanced API Response Example
json{
  "status": "success",
  "data": [
    {
      "rank": 1,
      "symbol": "SOL",
      "name": "Solana",
      "price": 98.45,
      "market_cap": 42000000000,
      "volume_24h": 8400000000,
      "tvl": 1800000000,
      "liquidity": 1680000000,
      "trust_score": 87.5,
      "score_breakdown": {
        "liquidity_score": 23.5,
        "volume_score": 19.0,
        "tvl_score": 17.5,
        "trend_score": 18.0,
        "market_health_score": 8.5,
        "risk_score": 4.5,
        "total_score": 87.5,
        "grade": "A",
        "confidence": 92.0,
        "details": {
          "liquidity_ratio": 0.04,
          "liquidity_depth": 0.85,
          "volume_to_mcap_ratio": 0.20,
          "volume_consistency": 0.88,
          "volume_7d_growth": 12.5,
          "tvl_to_mcap_ratio": 0.043,
          "tvl_7d_growth": 8.3,
          "tvl_30d_growth": 25.7,
          "tvl_volatility": 12.4,
          "short_term_trend": "uptrend",
          "medium_term_trend": "strong_uptrend",
          "long_term_trend": "uptrend",
          "volatility_30d": 45.2,
          "sharpe_ratio": 1.85,
          "rsi": 62.5,
          "top10_holders_percent": 35.2,
          "unique_holders": 2450000,
          "market_cap_rank": 5,
          "rug_pull_risk": "Low",
          "centralization_risk": "Low",
          "smart_contract_risk": "Low"
        }
      }
    }
  ]
}